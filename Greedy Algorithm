# 455. Assign Cookies
[LeetCode Link](https://leetcode.cn/problems/assign-cookies/)

**Problem**  
Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.

Each child `i` has a greed factor `g[i]`, which is the minimum size of a cookie that the child will be content with; and each cookie `j` has a size `s[j]`. If `s[j] >= g[i]`, we can assign the cookie `j` to the child `i`, and the child `i` will be content. Your goal is to maximize the number of your content children and output the maximum number.

**Example**

```text
Input: g = [1,2,3], s = [1,1]
Output: 1
Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. 
And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.
You need to output 1.

Input: g = [1,2], s = [1,2,3]
Output: 2
Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. 
You have 3 cookies and their sizes are big enough to gratify all of the children, 
You need to output 2.
```

**Constraints:**
*   1 <= g.length <= 3 * 10^4
*   0 <= s.length <= 3 * 10^4
*   1 <= g[i], s[j] <= 2^31 - 1

## My Understanding

### Note
```text

```

### Solution
```python
class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        g.sort()
        s.sort()
        child_i, cookie_i = 0, 0
        n_children, n_cookies = len(g), len(s)
        while child_i < n_children and cookie_i < n_cookies:
            if g[child_i] <= s[cookie_i]:
                child_i += 1
            cookie_i += 1
        return child_i

```
**Complexity**

*   Time Complexity: 
*   Space Complexity: 

---
# 135. Candy
[LeetCode Link](https://leetcode.cn/problems/candy/)

**Problem**  
There are `n` children standing in a line. Each child is assigned a rating value given in the integer array `ratings`.

You are giving candies to these children subjected to the following requirements:

*   Each child must have at least one candy.
*   Children with a higher rating get more candies than their neighbors.

Return *the minimum number of candies you need to have to distribute the candies to the children*.

**Example**

```text
Input: ratings = [1,0,2]
Output: 5
Explanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively.

Input: ratings = [1,2,2]
Output: 4
Explanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively.
The third child gets 1 candy because it satisfies the above two conditions.
```

**Constraints:**
*   n == ratings.length
*   1 <= n <= 2 * 10^4
*   0 <= ratings[i] <= 2 * 10^4

## My Understanding

### Note
```text
既然同时满足两个邻居很难，那我们就拆分成两个独立的子任务：
```

### Solution
```python
class Solution:
    def candy(self, ratings: List[int]) -> int:
        n = len(ratings)
        candies = [1] * n
        for i in range (1,n):
            if ratings[i] > ratings[i-1]:
                candies[i]=candies[i-1] + 1
        for i in range(n-1,0,-1):
            if ratings[i] < ratings[i-1]:
                candies[i-1]= max(candies[i] + 1, candies[i-1])
        
        return sum(candies)
```
**Complexity**

*   Time Complexity: 
*   Space Complexity: 

---
# 435. Non-overlapping Intervals
[LeetCode Link](https://leetcode.cn/problems/non-overlapping-intervals/)

**Problem**  
Given an array of intervals `intervals` where `intervals[i] = [start_i, end_i]`, return *the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping*.

**Example**

```text
Input: intervals = [[1,2],[2,3],[3,4],[1,3]]
Output: 1
Explanation: [1,3] can be removed and the rest of the intervals are non-overlapping.

Input: intervals = [[1,2],[1,2],[1,2]]
Output: 2
Explanation: You need to remove two [1,2] to make the rest of the intervals non-overlapping.

Input: intervals = [[1,2],[2,3]]
Output: 0
Explanation: You don't need to remove any of the intervals since they're already non-overlapping.
```

**Constraints:**
*   1 <= intervals.length <= 10^5
*   intervals[i].length == 2
*   -5 * 10^4 <= start_i < end_i <= 5 * 10^4

## My Understanding

### Note
```text
.sort(key=lambda x: x[1]): 把列表里的元素从小到大排序，排序的依据是每个元素的第二个值
按第一个数排序： intervals.sort(key=lambda x: x[0])
按第二个数从大到小排： intervals.sort(key=lambda x: x[1], reverse=True)
混合排序： intervals.sort(key=lambda x: (x[0], x[1]))  # 先看 x[0]，如果 x[0] 平手，再看 x[1]
先按第一个数从小到大；第一个数一样，按第二个数从大到小： intervals.sort(key=lambda x: (x[0], -x[1])) 
时间复杂度: $O(N \log N)$
空间复杂度: $O(N)$

如果两个元素的键值相等，它们原始的相对顺序会被保留。 
```

### Solution
```python
class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        if not intervals:
            return 0
        
        intervals.sort(key=lambda x: x[1]) # O(NlogN), space complexity O(N)
        # 第一个结束最早，无脑选中它  
        remove_count, prev_end = 0, intervals[0][1]
        #从第二个数开始处理 
        for i in range(1, len(intervals)): # O(N)
            curr_start = intervals[i][0]
            curr_end = intervals[i][1]
            
            if curr_start < prev_end:
                remove_count += 1
            else:
                prev_end = curr_end
        
        return remove_count
```
**Complexity**

*   Time Complexity: $O(N \log N) + O（N）$
*   Space Complexity: $O(N)$

---
