这是 LeetCode 455 的 Markdown 格式内容：

# 455. Assign Cookies
[LeetCode Link](https://leetcode.cn/problems/assign-cookies/)

**Problem**  
Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.

Each child `i` has a greed factor `g[i]`, which is the minimum size of a cookie that the child will be content with; and each cookie `j` has a size `s[j]`. If `s[j] >= g[i]`, we can assign the cookie `j` to the child `i`, and the child `i` will be content. Your goal is to maximize the number of your content children and output the maximum number.

**Example**

```text
Input: g = [1,2,3], s = [1,1]
Output: 1
Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. 
And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.
You need to output 1.

Input: g = [1,2], s = [1,2,3]
Output: 2
Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. 
You have 3 cookies and their sizes are big enough to gratify all of the children, 
You need to output 2.
```

**Constraints:**
*   1 <= g.length <= 3 * 10^4
*   0 <= s.length <= 3 * 10^4
*   1 <= g[i], s[j] <= 2^31 - 1

## My Understanding

### Note
```text

```

### Solution
```python
class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        g.sort()
        s.sort()
        child_i, cookie_i = 0, 0
        n_children, n_cookies = len(g), len(s)
        while child_i < n_children and cookie_i < n_cookies:
            if g[child_i] <= s[cookie_i]:
                child_i += 1
            cookie_i += 1
        return child_i

```
**Complexity**

*   Time Complexity: 
*   Space Complexity: 

---

这是 LeetCode 135 的 Markdown 格式内容：

# 135. Candy
[LeetCode Link](https://leetcode.cn/problems/candy/)

**Problem**  
There are `n` children standing in a line. Each child is assigned a rating value given in the integer array `ratings`.

You are giving candies to these children subjected to the following requirements:

*   Each child must have at least one candy.
*   Children with a higher rating get more candies than their neighbors.

Return *the minimum number of candies you need to have to distribute the candies to the children*.

**Example**

```text
Input: ratings = [1,0,2]
Output: 5
Explanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively.

Input: ratings = [1,2,2]
Output: 4
Explanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively.
The third child gets 1 candy because it satisfies the above two conditions.
```

**Constraints:**
*   n == ratings.length
*   1 <= n <= 2 * 10^4
*   0 <= ratings[i] <= 2 * 10^4

## My Understanding

### Note
```text
既然同时满足两个邻居很难，那我们就拆分成两个独立的子任务：
```

### Solution
```python
class Solution:
    def candy(self, ratings: List[int]) -> int:
        n = len(ratings)
        candies = [1] * n
        for i in range (1,n):
            if ratings[i] > ratings[i-1]:
                candies[i]=candies[i-1] + 1
        for i in range(n-1,0,-1):
            if ratings[i] < ratings[i-1]:
                candies[i-1]= max(candies[i] + 1, candies[i-1])
        
        return sum(candies)
```
**Complexity**

*   Time Complexity: 
*   Space Complexity: 

---
